# A
对点的坐标进行排序。对于每一组x和k，我们考虑设置一个半径r，检查[x-r,x+r]这个区间包含原序列中几个点。假设包含k个点，那么距离x最近的第k个点只用在离x-r最近的已包含的点和离x+r最近的已包含的点中选距离x最远的那个点，即为第k近的点。
考虑x的分布，共有三种情况，原序列左侧、中间和右侧（包含x与原序列点重合的情况）。对于左侧和右侧寻找第k近的点其实分别就是原序列中正数和倒数第k个点。下面我们讨论中间情况。
我们考虑对r进行向左二分答案，若check的点数为k则只需按照上述操作进行得到第k近的点即可。若最后check的点数比k少1，则考虑分别向左向右延申一个点，并去除第k+1近的点，最后得到第k近的点。若check为k+1，去除k+1，再得到k。
code:https://www.luogu.com.cn/paste/nd54p5db
# E
用gcd(a,b)=gcd(b,a%b)可得对于任何大于1的正整数x都满足gcd(x,2x-1)=1,变形可得gcd(n+1,n+n+1)=1。因为对m有限制，所以当n小于1e9时输出n+1，否则输出n-1。
code:https://www.luogu.com.cn/paste/ey5dcccb
# I
考虑到既要满足异色边最大又要保证连通，可以任选一个r对所有的b建边，再任选一个b对所有r建边。再进行所有r和所有b建边。为了防止边数不足n，考虑将所有r之间建边以及所有b之间建边。为了满足无重边，将边用set维护。为了防止在所有建边的过程中使得边的个数比n大，所以每建一条边都判断一下是否已经到达n条边。最后输出set内存的边即可。
code:https://www.luogu.com.cn/paste/i71m0s8g